## Counting Leaves

问题描述：搜索树的每层叶子节点

思路：使用深度优先搜索或者广度优先搜索

### 深度优先搜索DFS

1) 每个节点包含的信息包括**当前节点**和其**子节点**。当其子节点个数(度)为0时，可判定为叶子节点。因此，可以考虑使用vector对象。

```
//c++代码实现
#define NUM 30
vector<int> v[NUM];  //vector用于存放节点信息
int book[NUM];  //数组book用于存放每层的叶子节点个数
int maxdepth = -1;  //层数
void dfs(int index, int depth) {
  if(v[index].size() == 0) {
    book[depth]++;   //子节点个数(度)为0，叶子节点数加1
    maxdepth = max(maxdepth, depth);
    return ;
  }
  for(int i = 0; i < v[index].size(); i++)
    dfs(v[index][i], depth + 1);
}
```

## 广度优先搜索

```
//c++代码实现
# define NUM 30
vector<int> v[NUM];
int level[NUM];  //用于存放每个节点的层数
int book[NUM];  //用于存放每层的叶子节点个数
maxlevel = -1;  //度
void bfs() {
  queue <int> q;
  q.push(1);
  level[1] = 0;
  while(!q.empty()) {
    int index = q.front();  //取得队头元素
    q.pop();  //删除队头元素
    maxlevel = max(level[index], maxlevel);
    if(v[index].size() == 0)
      book[level[index]]++;  //度为0，叶子节点加1
    for(int i = 0; i < v[index].size(); i++) {
      q.push(v[index][i]);  //子节点压入队列
      level[v[index][i]] = level[index] + 1;  //节点层数加1
    }
  }
}
```
